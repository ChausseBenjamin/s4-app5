\section{Conception de l'analyseur lexical}

% ### **1.1** Définir les [[Lexical Unit|unité lexicale]] à l’aide d’[[Regular Expression|expression régulière]] et d'automates

\todo{Définir les unités lexicales à l’aide d’expressions régulières}\\
\todo{Représenter les unités lexicales à l’aide d’automates}\\
\todo{Proposer des classes Java qui implémentent l’analyse lexicale}\\

\subsection{Définir les unité lexicale à l’aide d’expressions régulières et d'automates}

\subsubsection{Littéraux}

Les littéraux sont des unité lexicales comme des nombres, des
valeurs booléennes etc\ldots C'est une valeur fixe directement
écrite dans le code source d'un programme. Hors, la tâche demandé nécessite
uniquement la détection de nombre entiers sans exposants. L'alphabet des
littéraux contient alors uniquement les nombres de 0 à 9.


\paragraph{Expression régulière}

\begin{align}
  \sum_{\textrm{literal}} &= \{0,1,2,3,4,5,6,7,8,9 \} \\
  \textrm{Expression} &= \sum^+_{\textrm{literal}}
\end{align}

L'expression régulière suivante présente celle d'en haut d'une façon plus régulière:
\begin{equation}
  \textrm{Expression} = (0|1|2|3|4|5|6|7|8|9)^+
\end{equation}

L'automate de la figure \ref{fig:fsm-literal} est une partie de l'automate complet de l'analyseur lexical.
Il fonctionne uniquement pour les littéraux de nombre entier.

\subsubsection{Opérateurs}

Dans le contexte du language de la problématique, les opérateurs sont des
unité lexicale permettant d'exécuté une évaluation arithmétique entre un
nombre à gauche de l'unité et un à droite. Les deux nombres étant des unités
de type littéraux. Les opérateurs reconnues sont l'addition, la soustraction,
la multiplication et la division. Aucun opérateur est constitué de plusieurs
lettres.

\paragraph{Expression régulière}

\begin{align}
  \sum_{\textrm{opérateurs}} &= \{+,-,*,/\} \\
  \textrm{Expression} &= \sum_{\textrm{opérateurs}}
\end{align}

De façon plus lisible, cette expression peut être présenté comme suit. Notez
que les apostrophes sont la juste pour identifier que c'est pas un symbole
d'expression régulière et bien une lettre.

\begin{equation}
  \textrm{Expression} = +|-|*|\ /
\end{equation}

L'automate de la figure \ref{fig:fsm-operator} est une partie de l'automate
complet de l'analyseur lexical. Il fonctionne juste pour les opérateurs à
symbole unique


\subsubsection{Identificateurs}

Dans le contexte du language de la problématique, deux opérandes sont
possible. Soit des littéraux ou des chaines de caractères. Ces derniers sont
formellement appelé "identificateurs". Ils sont valide uniquement s'il
commence par une lettre majuscule. Ils peuvent contenir des lettres
minuscules et majuscules ainsi que des underscores. Cependant ils peuvent pas
finir par un underscore et il ne peut pas avoir deux underscores de suite.
Ils sont minimalement une lettre de long.

\paragraph{Expression régulière}

Par soucis de simplicité, l'alphabet n'est pas mentionné. Les expressions suivantes présente l'expression régulière pour la détection d'identificateurs valide:
\begin{align}
  \textrm{Maj} &= (A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z) \\
  \textrm{Min} &= (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z) \\
  \textrm{Lettres} &= \textrm{Maj} | \textrm{Min}
\end{align}

Il serait plus simple de les écrire en \textit{Regex} comme suit, mais
malheureusement ce n'est pas demandé:

\begin{align}
  \text{Maj} &= [\textrm{A-Z}] \\
  \text{Min} &= [\textrm{a-z}] \\
  \text{Lettres} &= [\textrm{A-Za-z}] = [\textrm{A-z}]
\end{align}

L'expression est donc la suivante. Au lieu d'écrire
\begin{equation}
  \textrm{Expression}=\textrm{Maj} (\_?\textrm{Lettres}^+)*
\end{equation}

Ce qui veut dire, une majuscule suivie de zéro ou plus underscore optionnelle suivie d'une lettre ou plus.
\todo{I had a stroke reading above\ldots}


L'automate de la figure \ref{fig:fsm-identifier} est une partie de l'automate
complet de l'analyseur lexical. Il fonctionne uniquement pour les
identificateurs.


\subsubsection{Délimiteurs}

De nature, un délimiteurs est une unité lexicale qui délimite des portions de
programme. Dans le contexte du language de la problématique, les délimiteurs
sont uniquement les parenthèse standard. L'automate et l'expression régulière
seront donc identique à ceux des opérateurs. L'alphabet change pour
uniquement être les parenthèse.

\paragraph{Expression régulière}

\begin{align}
 \sum_{\textrm{délimiteurs}} &=\{(,)\}  \\
\textrm{Expression} &=\sum^{\textrm{délimiteurs}}
\end{align}

L'expression régulière suivante présente celle d'en haut d'une façon plus régulière:

\begin{equation}
  \textrm{Expression} = \textrm{ '(' } | \textrm{ ')' }
\end{equation}

L'automate de la figure \ref{fig:fsm-delimiter} est une partie de l'automate
complet de l'analyseur lexical. Il fonctionne uniquement pour les délimiteurs.

\subsection{Classes Java qui implémentent l’analyse lexicale}

Pour performer l'analyse lexical, des classes déjà existantes du projet de
départ on été utilisées. \verb|AnaLex| qui perform l'analyse lexical
à partir d'une expression donnée et implémente les automates définie plus
haut. \verb|Terminal| qui à été utilisé comme classe d'unité lexical et
contient donc son type et son lexème. \verb|AnaLex| va bâtir une liste
d'unité lexical qui est en fait des objects \verb|Terminal|. Ensuite une
classe static d'alphabet à été rajouté au projet, permettant d'utilisé des
fonctions qui vérifie qu'une lettre fait partie de certains alphabets comme
celui d'un opérateur, du début d'un identificateur, du corps d'un
identificateur etc. Cette dernière est utilisé pour évité de coder
directement les strings dans \verb|AnaLex|. Afin d'éviter d'alourdir
inutilment ce rapport le code est omis puisqu'il est déjà attaché à la remise
de ce rapport.
